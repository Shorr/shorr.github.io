<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式三：工厂方法模式、抽象工厂模式对比]]></title>
    <url>%2F2018%2F02%2F05%2Fdesign-patterns-03%2F</url>
    <content type="text"><![CDATA[转自知乎https://www.zhihu.com/question/20367734/answer/115807228 并整理文中例子以鼠标，键盘，耳麦为产品，惠普，戴尔为工厂 简单工厂模式简单工厂模式不是23种里的一种，简而言之，就是有一个专门生产某个产品的类。比如下图中的鼠标工厂，专业生产鼠标，给参数0，生产戴尔鼠标，给参数1，生产惠普鼠标。 工厂方法模式工厂方法模式也就是鼠标工厂是个父类，有生产鼠标这个方法。戴尔鼠标工厂、惠普鼠标工厂继承它，可以分别生产戴尔鼠标、惠普鼠标。生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。后续直接调用鼠标工厂.生产鼠标()即可。 抽象工厂模式抽象工厂模式也就是不仅生产鼠标，同时生产键盘。也就是PC厂商是个父类，有生产鼠标，生产键盘两个方法。戴尔工厂、惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘、惠普鼠标+惠普键盘。创建工厂时，若由戴尔工厂创建，后续工厂.生产鼠标()则生产戴尔鼠标，工厂.生产键盘()则生产戴尔键盘。 在抽象工厂模式中，增加一个工厂假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承PC厂商。之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类。即可。 在抽象工厂模式中，增加一个产品假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。之后在PC厂商这个父类中，增加生产耳麦的方法。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。 产品等级结构、产品族 产品等级结构：即产品的继承结构。在工厂方法模式中抽象类是鼠标，其子类有戴尔鼠标、惠普鼠标，则抽象鼠标与具体品牌的鼠标之间构成了一个产品等级结构，抽象鼠标是父类，而具体品牌的鼠标是其子类。 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如戴尔工厂生产的戴尔鼠标、戴尔键盘，戴尔鼠标位于鼠标产品等级结构中，戴尔键盘位于键盘产品等级结构中，戴尔鼠标、戴尔键盘构成了一个产品族。 定义描述及图片来源 http://blog.csdn.net/lovelion/article/details/9319323 对比总结 工厂方法模式 抽象工厂模式 只有一个产品等级结构 有多个产品等级结构(产品族) 只有一个抽象产品类 有多个抽象产品类 每个具体工厂可创建一个产品类实例 每个具体工厂可创建多个产品类实例]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android:persistent误用带来的灾难]]></title>
    <url>%2F2018%2F02%2F03%2Fpersistent-misuse%2F</url>
    <content type="text"><![CDATA[定义 Whether or not the application should remain running at all times — “true” if it should, and “false” if not. The default value is “false”. Applications should not normally set this flag; persistence mode is intended only for certain system applications. 上述为官网的描述，简言之：persistent属性是用来设置应用是否要一直运行。这个属性是为了系统级应用而设置，常规应用不应该将此属性置true。当被设为true时，此应用将永不会被杀死。 背景前段时间由于公司的相关业务，一直在和定制Pad厂商对接相关的技术。我们需求大致为：Pad启动时，我们自己的App将作为默认Launcher随系统一起启动。Pad出厂时我们的App作为系统级应用被一并打进Rom包，App升级时将采用静默安装的方式进行升级，升级过后的App将从系统级应用变为普通用户级应用。此过程可防止App被手动卸载后，依然可以保留初版的系统App。 App安装升级带来的问题 从系统App通过静默安装（pm install）升级为普通App，提示安装成功，但打开App时会崩溃。 通过adb install安装apk，提示安装成功，但打开App依然为旧版App的内容。此时跳转别的页面App会崩溃。 使用Android Studio安装（pm install），提示安装成功，但打开App依然为旧版App的内容。此时跳转别的页面App会崩溃。 注：上述的崩溃log均显示为当前Activity不能强转为当前的Activity，且系统设置里边显示版本号已经是安装后新版的版本号。上述问题重启Pad后，App均变为新版，一切变正常。 尝试解决上述问题 在Rom层级监听apk安装成功后，主动kill下App进程后再重启一下App，依然发现上述问题依旧，此方案无效。 排查App代码，发现注册文件application下android:persistent=&quot;true&quot;,去之。重新打包并内置Rom，测试后，上述问题解决。 总结android:persistent=&quot;true&quot;此属性最好只在系统级App下使用，即始终位于/system/app下的App。普通用户级的App要避免此属性的使用。当被设为true时，应用升级时进程将不会被正常杀死，所以才导致了上述问题的发生。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式二：工厂方法模式]]></title>
    <url>%2F2018%2F01%2F10%2Fdesign-patterns-02%2F</url>
    <content type="text"><![CDATA[含义官方：定义一个用于创建对象的接口，让子类决定实例化哪一个类。 白话：建设一个工厂，客户需要什么产品，工厂都可以对应生产，而不需要关心生产过程。 UML类图 实现方式以鞋厂生产不同类型的鞋子为例： 抽象产品类123456public abstract class Shoes &#123; public abstract void color(); public abstract void size();&#125; 具体的产品类继承于抽象产品类。 12345678910111213141516171819202122232425public class SportShoes extends Shoes &#123; @Override public void color() &#123; System.out.println("红色的运动鞋。"); &#125; @Override public void size() &#123; System.out.println("运动鞋的尺寸为43号。"); &#125;&#125;public class DressShoes extends Shoes &#123; @Override public void color() &#123; System.out.println("黑色的皮鞋。"); &#125; @Override public void size() &#123; System.out.println("皮鞋的尺寸为42号。"); &#125;&#125; 抽象的工厂类负责定义产品对象的产生。 1234public abstract class ShoesFactory &#123; public abstract &lt;T extends Shoes&gt; T createShoes(Class&lt;T&gt; c);&#125; 具体的工厂类负责如何具体生产一个产品对象。 123456789101112131415public class ChineseShoesFactory extends ShoesFactory &#123; @Override public &lt;T extends Shoes&gt; T createShoes(Class&lt;T&gt; c) &#123; Shoes shoes = null; try &#123; //通过反射实例化对象 shoes = (Shoes) Class.forName(c.getName()).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return (T) shoes; &#125;&#125; 场景类1234567891011121314public class Client &#123; public static void main(String[] args) &#123; ShoesFactory factory = new ChineseShoesFactory(); Shoes sportShoes = factory.createShoes(SportShoes.class); sportShoes.color(); sportShoes.size(); Shoes dressShoes = factory.createShoes(DressShoes.class); dressShoes.color(); dressShoes.size(); &#125;&#125; 简单工厂模式（静态工厂模式）将上述抽象工厂类ShoesFactory去掉，然后将具体工厂类ChineseShoesFactory中的createShoes修改为静态方法，其余保持不变，这就是简单工厂模式。当模块仅需一个工厂类时，就不需要此处的抽象工厂类了，此时便可适用简单工厂模式。 1234567891011121314public class ChineseShoesFactory &#123; public static &lt;T extends Shoes&gt; T createShoes(Class&lt;T&gt; c) &#123; Shoes shoes = null; try &#123; //通过反射实例化对象 shoes = (Shoes) Class.forName(c.getName()).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return (T) shoes; &#125;&#125; Android中的典型使用BitmapFactory类就是一个比较常见的简单工厂模式的工厂类。 总结工厂方法模式是new一个对象的替代品，在所有需要生成对象的地方都可以使用，但是需要慎重地考虑是否要增加一个工厂类进行管理，增加代码的复杂度。 优点:良好的封装性，高层模块只需要知道产品的抽象类即可，降低了模块间的耦合。缺点：增加了代码的复杂度。 鸣谢参考：《设计模式之禅》、《Android源码设计模式解析与实践》]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android串口操作库：EZ-SerialPort]]></title>
    <url>%2F2018%2F01%2F08%2Fandroid-ez-serialport%2F</url>
    <content type="text"><![CDATA[EZ-SerialPortEZ-SerialPort是基于Google android-serialport-api 修改与扩展的Android串口操作库。 EZ-SerialPort简化了串口的配置与读写操作，支持了多串口通道的操作，支持了多页面串口数据的同时读取功能。 Demo效果如下： Gradle 依赖在app的build.gradle 下添加： 添加依赖如下：123dependencies &#123; compile 'cn.shorr:ez-serialport:0.1.0'&#125; 添加适合的CPU平台ABI，如：1234567defaultConfig &#123; ... ndk &#123; abiFilters "armeabi", "armeabi-v7a", "x86" &#125;&#125; 不配置将默认为所有平台的ABI。 使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546//1.开始串口连接private void startSerialPortConnect() &#123; //配置串口参数 serialPortUtil = new SerialPortUtil(this, new SerialPortConfig("/dev/ttyMT1", 115200), //串口0 new SerialPortConfig("/dev/ttyMT2", 38400) //串口1 ); //设置为调试模式，打印收发数据 serialPortUtil.setDebug(true); //绑定串口服务 serialPortUtil.bindService(); //串口0数据读取监听（可在不同Activity中同时设置监听） serial0Read = new SerialRead(this); serial0Read.registerListener(0/*默认为0，此参数可省略*/, new Serial0ReadListener()); //串口1数据读取监听（可在不同Activity中同时设置监听） serial1Read = new SerialRead(this); serial1Read.registerListener(1, new Serial1ReadListener());&#125;//2.设置串口读取监听private class Serial0ReadListener implements SerialRead.ReadDataListener &#123; @Override public void onReadData(byte[] data) &#123; &#125;&#125;//3.串口发送数据SerialWrite.sendData(Context context, int port, byte[] data)；//如：串口0发送数据SerialWrite.sendData(this, 0/*默认为0，此参数可省略*/, content.getBytes("GBK"));//如：串口1发送数据SerialWrite.sendData(this, 1, content.getBytes("GBK"));//4.停止串口连接private void stopSerialPortConnect() &#123; serial0Read.unRegisterListener(); serial1Read.unRegisterListener(); serialPortUtil.unBindService();&#125;//5.获取设备所有的串口信息SerialPortFinder serialPortFinder = new SerialPortFinder();String[] devices = serialPortFinder.getAllDevicesPath(); 开发建议由于Android各硬件平台与驱动的差异性，在接收串口数据，即在通过监听获取byte[]字节数组时，一条完整的指令数据有可能被无规律分隔为多条byte[]字节数组。所以此时，需要将多条byte[]字节数组拼接为一条完整的指令，以便于指令的解析工作。 所以，在串口数据格式制定的初期一定要做好相关工作。比如，可以在数据格式中指定开始标记、数据长度、结束标记等，这样可以方便数据的拼接以及校验等工作。 Githubhttps://github.com/shorr/EZ-SerialPort]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式一：单例模式]]></title>
    <url>%2F2018%2F01%2F02%2Fdesign-patterns-01%2F</url>
    <content type="text"><![CDATA[含义确保某个类只有一个实例，且自实例化后向系统提供这个实例。避免产生多个对象消耗过多的资源。 UML类图 实现方式懒汉方式声明一个静态对象，且在用户第一次调用getInstance时进行初始化。 12345678910111213public class Singleton&#123; private static Singleton instance; private Singleton()&#123; &#125; public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 该方式单例在使用时才会实例化，synchronized保证了多线程下的同步问题，但也导致了每次调用getInstanced方法都要进行同步，造成不必要的开销。类加载快，获取单例慢。 饿汉方式声明一个静态对象，并在类第一次加载的时候进行初始化。 12345678910public class Singleton&#123; private static Singleton instance = new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return instance; &#125; &#125; 该方式单例在类第一次加载的时候进行实例化，调用getInstanced方法时不会有多线程问题。类加载慢，获取单例快。 双重检锁方式在需要时初始化单例，调用获取单例方法不用进行同步锁。 1234567891011121314151617public class Singleton&#123; private static volatile Singleton instance = null; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if(instance == null)&#123; //避免不必要的同步操作 synchronized(Singleton.class)&#123; //null情况下创建实例 if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; volatile作用：instance = new Singleton();该语句并不是一个原子操作。它经过如下过程： 1.给instance实例分配内存； 2.调用构造函数，初始化成员字段； 3.将instance对象指向分配的内存空间（此时instance已经不是null了）。 加volatile字段可以保证实例化时按1-2-3顺序执行；否则有可能是1-3-2顺序执行，此时该检锁方式将失效。 该方式资源利用率高，第一次执行getInstance时单例才会被初始化。解决了资源消耗、多余同步、线程安全问题。但是，该方式在某些高并发的情况下出现失效问题，发生概率很小。 静态内部类单例方式最推荐使用的单例实现方式。 12345678910111213public class Singleton&#123; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return SingletonHolder.instance; &#125; private static class SingletonHolder&#123; private static Singleton instance = new Singleton(); &#125;&#125; 该方式第一次加载Singleton类时不会初始化instance，只有在第一次调用getInstance的时候静态内部类会被加载并进一步完成instance的初始化。此方式还可以保证线程安全。 枚举方式1234567public enum Singleton&#123; INSTANCE; public void doSth()&#123; ... &#125;&#125; 该方式写法简单，默认的枚举实例创建是线程安全的，且在任何情况下它都是一个单例。 总结无论哪种方式，都是将构造函数私有化，并通过静态方法获取一个唯一实例，在这个过程中要保证线程的安全等。 此外还需要特别注意：如果我们的一个单例对象在内存中长久不使用，JVM就认为这个对象是一个垃圾，在CPU资源空闲的情况下该对象会被清理掉，下次再调用时就需要重新产生一个对象。所以在使用某些状态管理的单例时要特别注意。 对一般项目而言推荐：静态内部类单例方式、枚举方式。 鸣谢参考：《Android源码设计模式解析与实践》、《设计模式之禅》]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开源控件：字符索引栏EZ-CharIndexBar]]></title>
    <url>%2F2017%2F11%2F20%2Fandroid-ez-charindexbar%2F</url>
    <content type="text"><![CDATA[前言EZ-CharIndexBar是一个Android上的“字符索引栏”，效果类似WeChat通讯录右侧的索引栏样式。效果如下： Gradle 依赖在app的build.gradle 下添加如下依赖即可： 123dependencies &#123; compile 'cn.shorr:ez-charindexbar:0.1.2'&#125; 使用在布局xml文件中添加12345678910&lt;cn.shorr.charindexbar.CharIndexBar android:id="@+id/char_index_bar" android:layout_width="25dp" android:layout_height="match_parent" android:layout_alignParentRight="true" android:layout_marginBottom="20dp" app:barBackground="#3f000000" app:barChars="☆ABCDEFGHIJKLMNOPQRSTUVWXYZ#" app:barTextColor="@android:color/black" app:barTextSize="14sp" /&gt; barBackground：索引栏背景色 barChars：索引栏显示字符 barTextColor：索引栏字体颜色 barTextSize：索引栏字体大小 在Activity中如下操作12345678910111213141516171819202122232425262728//1.创建字符指示视图//使用默认参数字符指示视图charIndicateView = new CharIndicateView(this);/*使用自定义参数字符指示视图CharIndicateConfig config = CharIndicateConfig .create() .setViewSize(100) //视图大小(dp) .setTextSize(50) //字体大小(sp) .setTextBold(false) //字体是否加粗 .setTextColor(Color.WHITE) //字体加粗 .setBackgroundColor(Color.parseColor("#5f000000")) //视图背景色 .setBackgroundRadius(8); //视图背景圆角半径(dp)charIndicateView = new CharIndicateView(this, config);*///动态设置索引栏字符//charIndexBar.setChars("0123456789ABCDEFGHIJKLMNO");//2.索引栏和指示视图建立联系charIndexBar.setupWithIndicateView(charIndicateView);//3.设置选中监听事件charIndexBar.setOnSelectedListener(new CharIndexBar.OnSelectedListener() &#123; @Override public void onSelected(int position, String selectedChar) &#123; Log.e(TAG, "选中--" + selectedChar); //根据选中的字符来定位列表的位置 ... &#125;&#125;); Githubhttps://github.com/shorr/ez-charindexbar]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View：实例篇——字符滑动栏]]></title>
    <url>%2F2016%2F12%2F11%2Fandroid-custom-view-instance%2F</url>
    <content type="text"><![CDATA[前言现在在大多数具有联系人功能APP上边，很多都具有字符索引栏的功能，以方便用户更快的定位到要找的联系人。尤其是在联系人数量比较多的时候，这个功能就显得尤为快速方便了。此篇博客，将教大家来实现这么一个字符滑动栏。话不多说，先看下效果图。 其中，最右侧的滑动栏我们称为“字符滑动栏”，命名为CharSlideBar; 中间显示字符的视图我们称为“字符指示视图”，命名为CharIndicateView。 步骤 1、绘制出字符滑动栏CharSlideBar2、添加字符滑动栏CharSlideBar的点击滑动监听事件3、绘制出字符指示图CharIndicateView4、字符滑动栏CharSlideBar与字符指示图CharIndicateView建立关联 具体实现绘制出字符滑动栏CharSlideBar自定义View属性1234567891011&lt;!--字符索引栏的自定义属性--&gt;&lt;declare-styleable name="CharSlideBar"&gt; &lt;!--字体大小--&gt; &lt;attr name="barTextSize" format="dimension" /&gt; &lt;!--字体颜色--&gt; &lt;attr name="barTextColor" format="color" /&gt; &lt;!--要显示的字符--&gt; &lt;attr name="barChars" format="string" /&gt; &lt;!--背景色--&gt; &lt;attr name="barBackground" format="color" /&gt;&lt;/declare-styleable&gt; 实现CharSlideBar类，继承自View同时实现其构造方法，并初始化相关自定义属性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class CharSlideBar extends View &#123; /*可自定义相关属性*/ private String mChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ#"; //要显示的所有字符(此处为默认值) private int mBackgroundColor = Color.GRAY; //背景色(此处为默认值) private int mCharTextSize = 30; //字体大小（此处为默认值） private int mCharTextColor = Color.BLACK; //字体颜色（此处为默认值） private int mCanvasColor = Color.TRANSPARENT; //画布颜色 private int mLastSelectedPosition = -1; //记录上次选中的位置 private Paint mPaint; //画笔 private Paint.FontMetricsInt mFontMetricsInt; //字体度量值 private CharIndicateView mCharIndicateView; //字符指示视图 private OnSelectedListener mOnSelectedListener; //字符选中的监听 public CharSlideBar(Context context) &#123; this(context, null); &#125; public CharSlideBar(Context context, AttributeSet attrs) &#123; super(context, attrs); //初始化View相关自定义属性 initFromAttributes(context, attrs); //初始化相关操作 init(); &#125; /** * 初始化View相关自定义属性 * * @param context * @param attrs */ private void initFromAttributes(Context context, AttributeSet attrs) &#123; //获取相关View属性 TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.CharSlideBar, 0, 0); try &#123; String chars = a.getString(R.styleable.CharSlideBar_barChars); mChars = chars == null ? mChars : chars; mCharTextSize = a.getDimensionPixelSize(R.styleable.CharSlideBar_barTextSize, mCharTextSize); mCharTextColor = a.getColor(R.styleable.CharSlideBar_barTextColor, mCharTextColor); mBackgroundColor = a.getColor(R.styleable.CharSlideBar_barBackground, mBackgroundColor); &#125; finally &#123; //回收TypedArray a.recycle(); &#125; &#125; /** * 初始化操作 */ private void init() &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); //文字水平居中显示 mPaint.setTextAlign(Paint.Align.CENTER); //设置字体大小 mPaint.setTextSize(mCharTextSize); //设置字体颜色 mPaint.setColor(mCharTextColor); //获取FontMetricsInt mFontMetricsInt = mPaint.getFontMetricsInt(); &#125; ...//省略&#125; 此处不再详细介绍，具体可参见上篇博客：Android自定义View：基础篇 重写onDraw(Canvas canvas)方法12345678910111213141516171819@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //设置索引栏背景色 canvas.drawColor(mCanvasColor); //单个字符所占的高度 float singleCharHeight = ((float) getHeight()) / mChars.length(); //字符要显示的x值 float charX = ((float) getWidth()) / 2; //计算出字体高度 int fontHeight = mFontMetricsInt.descent - mFontMetricsInt.ascent; //计算出竖直方向居中时的偏移量 float centerYOffset = singleCharHeight / 2 - (-mFontMetricsInt.ascent - fontHeight / 2); //根据x、y值画出所有字符 for (int i = 0; i &lt; mChars.length(); i++) &#123; canvas.drawText(mChars.substring(i, i + 1), charX, singleCharHeight * (i + 1) - centerYOffset, mPaint); &#125;&#125; 在该方法内： 首先得到索引栏的高度，除以所有字符的个数，即得到单个字符的高度，便实现了将所有字符平分高度的目的； 得到宽度的中间X值，目的是为了字符水平居中； 由于canvas的drawText()方法中的y值为Text的baseline,所以要想实现文本的垂直方向居中，就必须计算出文本的垂直方向的中间线与所占布局中间线的偏移量； 根据x、y值,以及竖直方向居中时的偏移量，我们将所有字符平均绘制在垂直方向上。 注：计算文本的垂直方向的中间线与所占布局中间线的偏移量的方法为： 首先看一下Android中的字体度量： 其中baseline为基线，基线以上为负值，以下为正值。即top, ascent为负值，descent, bottom为正值。 如图，若想要文本垂直居中，则需要让文本中间线与布局中间线重合即可。所以对照此图就不难计算出两个中间线的偏移量了。 添加字符索引栏CharSlideBar的点击滑动监听事件重写onTouchEvent(MotionEvent event)方法：1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; int action = event.getAction(); switch (action) &#123; case MotionEvent.ACTION_DOWN: //手指按下 //设置画布颜色 mCanvasColor = mBackgroundColor; //重新绘制 invalidate(); //显示字符指示View if (mCharIndicateView != null) &#123; mCharIndicateView.setVisibility(View.VISIBLE); &#125; //根据Y值得到选中的位置 selectedPositionByY(event.getY()); return true; case MotionEvent.ACTION_MOVE: //手指滑动 //根据Y值得到选中的位置 selectedPositionByY(event.getY()); return true; case MotionEvent.ACTION_UP: //手指抬起 //画布颜色设为透明 mCanvasColor = Color.TRANSPARENT; //重新绘制 invalidate(); //隐藏字符指示View if (mCharIndicateView != null) &#123; mCharIndicateView.setVisibility(View.GONE); &#125; //复位记录上次选中位置的值 mLastSelectedPosition = -1; return true; &#125; return super.onTouchEvent(event);&#125; 首先根据按下与抬起的动作来设置索引栏的背景色。同时根据获取的View的Y值来计算出按下的相应字符。根据Y值得到选中的位置即相应字符的方法为：12345678910111213141516171819202122232425262728293031/** * 根据View的Y值得到选中的字符位置 * * @param y */private void selectedPositionByY(float y) &#123; //若滑动范围超出索引栏的高度范围，不再计算位置 if (y &lt; 0 || y &gt; getHeight()) &#123; return; &#125; //单个字符所占的高度 float singleCharHeight = ((float) getHeight()) / mChars.length(); //计算出当前选中的位置 int position = (int) (y / singleCharHeight); //防止重复显示 if (position != mLastSelectedPosition) &#123; //根据选中位置，获取相应位置的字符 String selectedChar = mChars.substring(position, position + 1); //展示选中的字符 if (mCharIndicateView != null) &#123; mCharIndicateView.showSelectedChar(selectedChar); &#125; //设置监听的回调方法 if (mOnSelectedListener != null) &#123; mOnSelectedListener.onSelected(position, selectedChar); &#125; //记录下当前位置 mLastSelectedPosition = position; &#125;&#125; 随后，我们为字符索引栏设置一个监听选中事件的接口,并添加设置方法，并在上述的selectedPositionByY(float y)中实现了接口方法的回调。123456789101112131415161718192021/** * 字符选中的监听事件 */public interface OnSelectedListener &#123; /** * 选中的回调方法 * * @param position 选中的位置 * @param selectedChar 选中的字符 */ public void onSelected(int position, String selectedChar);&#125;/** * 设置监听事件 * * @param onSelectedListener */public void setOnSelectedListener(OnSelectedListener onSelectedListener) &#123; mOnSelectedListener = onSelectedListener;&#125; 这样我们就可以在相应的Activity中设置选中监听事件了。 绘制出字符指示视图CharIndicateView自定义View属性1234567891011&lt;!--字母指示视图的自定义属性--&gt;&lt;declare-styleable name="CharIndicateView"&gt; &lt;!--字体大小--&gt; &lt;attr name="indicateTextSize" format="dimension" /&gt; &lt;!--字体颜色--&gt; &lt;attr name="indicateTextColor" format="color" /&gt; &lt;!--背景色--&gt; &lt;attr name="indicateBackground" format="color" /&gt; &lt;!--背景半径--&gt; &lt;attr name="indicateBackgroundRadius" format="dimension" /&gt;&lt;/declare-styleable&gt; 实现CharIndicateView类，继承自TextView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class CharIndicateView extends TextView &#123; /*可自定义相关属性*/ private int mIndicateTextSize = 50; //字体大小（此处为默认值） private int mIndicateTextColor = Color.BLACK; //字体颜色（此处为默认值） private int mBackgroundColor = Color.GRAY; //背景色(此处为默认值) private int mBackgroundRadius = 10; //矩形背景圆角半径(此处为默认值) public CharIndicateView(Context context) &#123; this(context, null); &#125; public CharIndicateView(Context context, AttributeSet attrs) &#123; super(context, attrs); //初始化View相关自定义属性 initFromAttributes(context, attrs); //初始化 init(); &#125; /** * 初始化View相关自定义属性 * * @param context * @param attrs */ private void initFromAttributes(Context context, AttributeSet attrs) &#123; //获取相关View属性 TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.CharIndicateView, 0, 0); try &#123; mIndicateTextSize = a.getDimensionPixelSize(R.styleable.CharIndicateView_indicateTextSize, mIndicateTextSize); mIndicateTextColor = a.getColor(R.styleable.CharIndicateView_indicateTextColor, mIndicateTextColor); mBackgroundColor = a.getColor(R.styleable.CharIndicateView_indicateBackground, mBackgroundColor); mBackgroundRadius = a.getDimensionPixelSize(R.styleable.CharIndicateView_indicateBackgroundRadius, mBackgroundRadius); &#125; finally &#123; //回收TypedArray a.recycle(); &#125; &#125; /** * 初始化操作 */ private void init() &#123; //设置圆角矩形背景 // float[] outerRadii = &#123;10, 10, 10, 10, 10, 10, 10, 10&#125;; float[] outerRadii = new float[8]; for (int i = 0; i &lt; outerRadii.length; i++) &#123; outerRadii[i] = mBackgroundRadius; &#125; RoundRectShape shape = new RoundRectShape(outerRadii, null, null); ShapeDrawable shapeDrawable = new ShapeDrawable(shape); shapeDrawable.getPaint().setColor(mBackgroundColor); //将圆角矩形背景设置到当前View this.setBackgroundDrawable(shapeDrawable); //文本居中显示 this.setGravity(Gravity.CENTER); //设置字体大小 this.setTextSize(mIndicateTextSize); //设置字体颜色 this.setTextColor(mIndicateTextColor); //默认不显示该布局 this.setVisibility(View.GONE); &#125; /** * 展示选中字符 * * @param selectedChar 要显示的字符 */ public void showSelectedChar(String selectedChar) &#123; this.setText(selectedChar); &#125;&#125; 字符指示布局的实现比较简单，直接继承自TextView，在初始化中设置了文本的颜色、大小、圆角矩形背景，并默认隐藏了该布局。此外，还添加了showSelectedChar(String selectedChar)方法，来显示相应的字符。 字符索引栏CharSlideBar与字符指示视图CharIndicateView建立关联在CharSlideBar我们添加如下关联方法：12345678/** * 和字符指示View建立联系 * * @param charIndicateView */public void setupWithIndicateView(CharIndicateView charIndicateView) &#123; mCharIndicateView = charIndicateView;&#125; 然后在上述的selectedPositionByY(float y)中调用了CharIndicateView的showSelectedChar(String selectedChar)方法。 到此，我们就可以实现本文开始时的效果了。 在应用中的使用方法布局文件activity_main.xml:1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!--联系人列表--&gt; &lt;ListView android:id="@+id/contact_listview" android:layout_width="match_parent" android:layout_height="match_parent" android:divider="@android:color/transparent" android:dividerHeight="0dp" /&gt; &lt;!--字符索引栏--&gt; &lt;cn.shorr.widget.CharSlideBar android:id="@+id/char_slider_bar" android:layout_width="25dp" android:layout_height="match_parent" android:layout_alignParentRight="true" android:layout_marginBottom="20dp" android:paddingBottom="10dp" android:paddingTop="10dp" app:barBackground="#3f000000" app:barChars="☆ABCDEFGHIJKLMNOPQRSTUVWXYZ#" app:barTextColor="@android:color/black" app:barTextSize="15sp" /&gt; &lt;!--字符指示视图--&gt; &lt;cn.shorr.widget.CharIndicateView android:id="@+id/char_indicate_view" android:layout_width="100dp" android:layout_height="100dp" android:layout_centerInParent="true" app:indicateBackground="#5f000000" app:indicateBackgroundRadius="5dp" app:indicateTextColor="@android:color/white" app:indicateTextSize="20sp" /&gt;&lt;/RelativeLayout&gt; Activity：MainActivity:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MainActivity extends AppCompatActivity &#123; private final String TAG = this.getClass().getSimpleName(); private List&lt;ContactBean&gt; mContactList; //联系人集合 private ListView mContactListView; //联系人列表 private CharSlideBar mCharSlideBar; //字符索引栏 private CharIndicateView mCharIndicateView; //字符指示视图 private ContactlistAdapter mContactListAdapter; //联系人列表适配器 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化变量 initVariables(); //初始化View initView(); &#125; /** * 初始化变量 */ private void initVariables() &#123; ContactModel model = new ContactModel(); mContactList = model.getContactList(); mContactListAdapter = new ContactlistAdapter(this, mContactList); &#125; /** * 初始化View */ private void initView() &#123; mContactListView = (ListView) findViewById(R.id.contact_listview); mCharSlideBar = (CharSlideBar) findViewById(R.id.char_slider_bar); mCharIndicateView = (CharIndicateView) findViewById(R.id.char_indicate_view); //联系人设置适配器 mContactListView.setAdapter(mContactListAdapter); //索引栏和指示视图建立联系 mCharSlideBar.setupWithIndicateView(mCharIndicateView); //设置选中监听事件 mCharSlideBar.setOnSelectedListener(new CharSlideBar.OnSelectedListener() &#123; @Override public void onSelected(int position, String selectedChar) &#123; Log.e(TAG, "选中--" + selectedChar); //根据选中的字符来定位ListView的位置 locateListViewPositionByChar(selectedChar); &#125; &#125;); &#125; /** * 根据选中的字符来定位ListView的位置 * * @param selectedChar */ private void locateListViewPositionByChar(String selectedChar) &#123; //遍历联系人列表找到对应字符的位置 for (int i = 0; i &lt; mContactList.size(); i++) &#123; String nameInitial = mContactList.get(i).getNameInitial(); if (nameInitial.equals(selectedChar)) &#123; //定位ListView的位置 mContactListView.setSelection(i); break; &#125; &#125; &#125;&#125; 源码及DemoDemo源码 请点击此处下载(https://github.com/shorr/notes_demo/tree/master/CharSlideBarDemo)]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View：基础篇]]></title>
    <url>%2F2016%2F11%2F25%2Fandroid-custom-view-base%2F</url>
    <content type="text"><![CDATA[前言在平常的开发工作中，由于各种特殊业务的需求，以及UI的各种脑洞设计，在这种场景下，Android中的基本控件就有些力不从心了。由此，掌握自定义View已慢慢变成大家必备的技能之一了。今天，就带大家进入自定义View的基础篇。 下边就是我们今天要实现的简单自定义View的效果图：其中，蓝色的为CustomView背景色，中间红色区域为CustomView的内容显示区域，我们暂称为ContentView。 概括自定义View的基本步骤如下： 1、 继承View类或View的子类2、 实现自定义View属性3、 重写onMeasure()方法4、 重写onDraw()方法 小注：以上步骤2、3、4可以根据自己的需求定制，非必需实现步骤。 具体实现继承View类或View的子类这一步比较简单，只需要实现一个继承自View或View子类的类,并实现构造方法即可。若我们要完全自己定义View控件，可如下操作： 12345678910111213public class CustomView extends View &#123; public CustomView(Context context) &#123; this(context, null); &#125; public CustomView(Context context, AttributeSet attrs) &#123; super(context, attrs); //...其它初始化操作 &#125;&#125; 此外，如果我们是在View子类的基础上进行自定义控件，类似操作如下： 12345678910111213public class CustomImageView extends ImageView &#123; public CustomImageView(Context context) &#123; this(context, null); &#125; public CustomImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); //...其它初始化操作 &#125;&#125; 实现自定义View属性在项目res/values/下新建attrs.xml(当然其它名称也是可以的)，在其中声明相关属性如下：12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;!--自定义View属性--&gt; &lt;declare-styleable name="CustomView"&gt; &lt;attr name="contentWidth" format="dimension" /&gt; &lt;attr name="contentHeight" format="dimension" /&gt; &lt;attr name="contentColor" format="color" /&gt; &lt;attr name="gravity" format="enum"&gt; &lt;enum name="left" value="0" /&gt; &lt;enum name="right" value="1" /&gt; &lt;enum name="center" value="2" /&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 其中，attar的格式即单位有：dimension(尺寸)、boolean(布尔)、color(颜色)、enum(枚举)、flag（位或）、float（浮点）、fraction(百分比)、integer(整型)、reference(资源引用)、string(字符串)。 在布局文件res/layout/activity_mian.xml的用法如下：1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:shorr="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center"&gt; &lt;cn.shorr.customview.CustomView android:layout_width="300dp" android:layout_height="300dp" android:background="@android:color/holo_blue_light" shorr:contentColor="@android:color/holo_red_light" shorr:contentHeight="200dp" shorr:contentWidth="200dp" shorr:gravity="center" /&gt;&lt;/RelativeLayout&gt; 注意：引用自定义属性，需要声明命名空间：xmlns:shorr=&quot;http://schemas.android.com/apk/res-auto&quot; 在CustomView的构造方法中初始化相关自定义属性：1234567891011121314151617181920/** * 初始化View相关自定义属性 * * @param context * @param attrs */private void initFromAttributes(Context context, AttributeSet attrs) &#123; //获取相关View属性 TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.CustomView, 0, 0); try &#123; mContentWidth = a.getDimensionPixelSize(R.styleable.CustomView_contentWidth, 0); mContentHeight = a.getDimensionPixelSize(R.styleable.CustomView_contentHeight, 0); mContentColor = a.getColor(R.styleable.CustomView_contentColor, Color.TRANSPARENT); mGravity = a.getInteger(R.styleable.CustomView_gravity, -1); &#125; finally &#123; //回收TypedArray a.recycle(); &#125;&#125; 注意：TypedArray对象是一个共享资源，使用后必须调用recycle()回收。目的是为了缓存资源，这样每次调用TypedArray的时候都不再需要重新分配内存，方便了其它地方的复用。 重写onMeasure()方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //获取宽高的尺寸 int width = getMeasureSize(MeasureOrientation.WIDTH, mContentWidth, widthMeasureSpec); int height = getMeasureSize(MeasureOrientation.HEIGHT, mContentHeight, heightMeasureSpec); //设置测量尺寸 setMeasuredDimension(width, height);&#125;/** * 得到宽度测量的尺寸大小 * * @param orientation 测量的方向（宽高） * @param defalutSize 默认尺寸大小 * @param measureSpec 测量的规则 * @return 返回测量的尺寸 */private int getMeasureSize(MeasureOrientation orientation, int defalutSize, int measureSpec) &#123; int result = defalutSize; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: //无限制大小 result = defalutSize; break; case MeasureSpec.AT_MOST: //对应wrap_content //如果设置了gravity属性，则忽略padding属性 if (mGravity != -1) &#123; result = defalutSize; break; &#125; if (orientation == MeasureOrientation.WIDTH) &#123; //测量的宽 result = getPaddingLeft() + defalutSize + getPaddingRight(); &#125; else if (orientation == MeasureOrientation.HEIGHT) &#123; //测量的高 result = getPaddingTop() + defalutSize + getPaddingBottom(); &#125; break; case MeasureSpec.EXACTLY: //对应match_parent or dp/px result = specSize; break; &#125; return result;&#125; 在getMeasureSize()方法中，我们通过measureSpec得到当前测量的大小和模式。并通过不同的模式我们计算得到了最终的CustomeView的尺寸大小。 SpecMode有三种类型： UNSPECIFIED：父容器对View没有任何限制。多用于系统内部的测量中。 AT_MOST：父容器给View的最大可用尺寸。它对应于View的wrap_content属性。 EXACTLY：父容器给View的具体可用尺寸。它对应于View的match_parent或dp/px(具体的尺寸)。 注意：在AT_MOST模式，即wrap_content属性下，要处理好View的padding属性。 此外，MeasureOrientation为自定义的枚举，为了区分记录View测量的方向（宽、高）：123private enum MeasureOrientation &#123; //View测量方向（宽、高）的枚举 WIDTH, HEIGHT&#125; 最后，得到测量后的值后，我们需要通过setMeasuredDimension(width, height);来为CustomeView设置测量值。 重写onDraw()方法123456789101112131415161718192021@Overrideprotected void onDraw(Canvas canvas) &#123; //获取测量后的宽高 int width = getWidth(); int height = getHeight(); //获取View的Padding int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int paddingTop = getPaddingTop(); int paddingBottom = getPaddingBottom(); //设置ContentView的Rect Rect rect = null; if (mGravity == -1) &#123; //如果没有设置gravity属性，设置padding属性 rect = new Rect(paddingLeft, paddingTop, width - paddingRight, height - paddingBottom); &#125; else &#123; //如果设置gravity属性，不设置padding属性 rect = getContentRect(width, height, mGravity); &#125; //绘制ContentView canvas.drawRect(rect, mPaint);&#125; 在onDraw()方法中，我们首先获取了CustomView的宽高、padding值，并根据有无设置gravity属性来分别处理了ContentView要显示矩形范围。最后，通过drawRect()方法绘制出了要显示的ContentView。 效果展示设置padding属性1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:shorr="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center"&gt; &lt;cn.shorr.customview.CustomView android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@android:color/holo_blue_light" android:paddingBottom="30dp" android:paddingLeft="20dp" android:paddingRight="5dp" android:paddingTop="10dp" shorr:contentColor="@android:color/holo_red_light" shorr:contentHeight="200dp" shorr:contentWidth="200dp" /&gt;&lt;/RelativeLayout&gt; 效果图： 设置gravity属性1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:shorr="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center"&gt; &lt;cn.shorr.customview.CustomView android:layout_width="300dp" android:layout_height="300dp" android:background="@android:color/holo_blue_light" shorr:contentColor="@android:color/holo_red_light" shorr:contentHeight="200dp" shorr:contentWidth="200dp" shorr:gravity="center" /&gt;&lt;/RelativeLayout&gt; 效果图： CustomView完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package cn.shorr.customview;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Rect;import android.util.AttributeSet;import android.view.View;/** * 自定义简易View * Created by Shorr on 2016/11/20. */public class CustomView extends View &#123; /*自定义属性*/ private int mContentWidth; //默认宽度,单位px private int mContentHeight; //默认高度,单位px private int mContentColor; //View的颜色 private int mGravity; //View的Gravity属性 private enum MeasureOrientation &#123; //View测量方向（宽、高）的枚举 WIDTH, HEIGHT &#125; private Paint mPaint; //定义一个画笔 public CustomView(Context context) &#123; this(context, null); &#125; public CustomView(Context context, AttributeSet attrs) &#123; super(context, attrs); //初始化相关自定义属性 initFromAttributes(context, attrs); //初始化View initView(); &#125; /** * 初始化View相关自定义属性 * * @param context * @param attrs */ private void initFromAttributes(Context context, AttributeSet attrs) &#123; //获取相关View属性 TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.CustomView, 0, 0); try &#123; mContentWidth = a.getDimensionPixelSize(R.styleable.CustomView_contentWidth, 0); mContentHeight = a.getDimensionPixelSize(R.styleable.CustomView_contentHeight, 0); mContentColor = a.getColor(R.styleable.CustomView_contentColor, Color.TRANSPARENT); mGravity = a.getInteger(R.styleable.CustomView_gravity, -1); &#125; finally &#123; //回收TypedArray a.recycle(); &#125; &#125; /** * 初始化View操作 */ private void initView() &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); //设置画笔颜色 mPaint.setColor(mContentColor); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //获取宽高的尺寸 int width = getMeasureSize(MeasureOrientation.WIDTH, mContentWidth, widthMeasureSpec); int height = getMeasureSize(MeasureOrientation.HEIGHT, mContentHeight, heightMeasureSpec); //设置测量尺寸 setMeasuredDimension(width, height); &#125; /** * 得到宽度测量的尺寸大小 * * @param orientation 测量的方向（宽高） * @param defalutSize 默认尺寸大小 * @param measureSpec 测量的规则 * @return 返回测量的尺寸 */ private int getMeasureSize(MeasureOrientation orientation, int defalutSize, int measureSpec) &#123; int result = defalutSize; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: //无限制大小 result = defalutSize; break; case MeasureSpec.AT_MOST: //对应wrap_content //如果设置了gravity属性，则忽略padding属性 if (mGravity != -1) &#123; result = defalutSize; break; &#125; if (orientation == MeasureOrientation.WIDTH) &#123; //测量的宽 result = getPaddingLeft() + defalutSize + getPaddingRight(); &#125; else if (orientation == MeasureOrientation.HEIGHT) &#123; //测量的高 result = getPaddingTop() + defalutSize + getPaddingBottom(); &#125; break; case MeasureSpec.EXACTLY: //对应match_parent or dp/px result = specSize; break; &#125; return result; &#125; @Override protected void onDraw(Canvas canvas) &#123; //获取测量后的宽高 int width = getWidth(); int height = getHeight(); //获取View的Padding int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int paddingTop = getPaddingTop(); int paddingBottom = getPaddingBottom(); //设置ContentView的Rect Rect rect = null; if (mGravity == -1) &#123; //如果没有设置gravity属性，设置padding属性 rect = new Rect(paddingLeft, paddingTop, width - paddingRight, height - paddingBottom); &#125; else &#123; //如果设置gravity属性，不设置padding属性 rect = getContentRect(width, height, mGravity); &#125; //绘制ContentView canvas.drawRect(rect, mPaint); &#125; /** * 获取ContentView的Rect * * @param width View的Width * @param height View的Height * @param gravity View的Gravity * @return */ private Rect getContentRect(int width, int height, int gravity) &#123; Rect rect = null; switch (gravity) &#123; case 0: //left rect = new Rect(0, 0, width - (width - mContentWidth), height - (height - mContentHeight)); break; case 1: //right rect = new Rect(width - mContentWidth, 0, height, height - (height - mContentHeight)); break; case 2: //center rect = new Rect((width - mContentWidth) / 2, (height - mContentHeight) / 2, width - ((width - mContentWidth) / 2), height - ((height - mContentHeight) / 2)); break; default: break; &#125; return rect; &#125;&#125; 结语今天，主要介绍了要实现一个基础自定义View的步骤，本篇demo只是简单的实现了一个CustomView,具体的实现效果大家可以根据自己的需求进行具体的定制。下一篇，将结合项目具体需求，给大家带来一个自定义View的实例篇，敬请期待~ Demo源码 请点击此处下载(https://github.com/shorr/notes_demo/tree/master/CustomView)]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义View</tag>
      </tags>
  </entry>
</search>
